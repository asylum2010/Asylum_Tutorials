
#version 440

#define PI				3.1415926535897932
#define TWO_PI			6.2831853071795864
#define HALF_PI			1.5707963267948966
#define ONE_OVER_PI		0.3183098861837906

#define NUM_SLICES		3
#define NUM_STEPS		3
#define RADIUS			2.0		// in world space
#define FALLOFF_START2	0.16
#define FALLOFF_END2	4.0

layout (binding = 0) uniform sampler2D gbufferDepth;
layout (rgba16f, binding = 1) uniform readonly image2D gbufferNormals;
layout (r16ui, binding = 2) uniform readonly uimage2D ldsLUT;
layout (r16f, binding = 3) uniform writeonly image2D outputAO; 

layout (location = 0) uniform vec4 projInfo;
layout (location = 1) uniform vec4 clipInfo;

float R1Sequence(float s0, int n)
{
	return fract(s0 + float(n) * 0.6180339887498948482);
}

vec2 R2Sequence(ivec2 loc)
{
	uint index = imageLoad(ldsLUT, loc % 64).r;
	return fract(vec2(0.5) + float(index) * vec2(0.75487766624669276005, 0.5698402909980532659114));
}

vec4 GetViewPosition(vec2 loc, float currstep)
{
	int miplevel = clamp(int(floor(log2(currstep / PREFETCH_CACHE_SIZE))), 0, NUM_MIP_LEVELS - 1);
	
	vec2 basesize = vec2(textureSize(gbufferDepth, 0));
	vec2 ndccoord = (loc / basesize);

	// NOTE: don't use texelFetch as it might do out-of-bound reads	
	float d = textureLod(gbufferDepth, ndccoord, miplevel).r;
	vec4 ret = vec4(0.0, 0.0, 0.0, d);

	ret.z = clipInfo.x + d * (clipInfo.y - clipInfo.x);
	ret.xy = (vec2(loc) * projInfo.xy + projInfo.zw) * ret.z;

	return ret;
}

float Falloff(float dist2, float cosh)
{
	return 2.0 * clamp((dist2 - FALLOFF_START2) / (FALLOFF_END2 - FALLOFF_START2), 0.0, 1.0);
}

layout (local_size_x = THREADGROUP_SIZE, local_size_y = THREADGROUP_SIZE) in;
void main()
{
	ivec2 loc		= ivec2(gl_GlobalInvocationID.xy);

	// NOTE: must add half-pixel offset or you get unwanted contours and "stripes"
	vec2 floc		= vec2(loc) + vec2(0.5);
	vec2 offset;
	vec2 noise		= R2Sequence(loc);
	vec4 vpos		= GetViewPosition(floc, 1.0);
	float ao		= 0.0;

	if (vpos.w == 1.0) {
		imageStore(outputAO, loc, vec4(1.0));
		return;
	}

	vec4 s;
	vec3 vnorm		= imageLoad(gbufferNormals, loc).rgb;
	vec3 vdir		= normalize(-vpos.xyz);
	vec3 dir, ws;
	vec2 horizons;

	float radius	= (RADIUS * clipInfo.z) / vpos.z;
	float dist2, invdist, falloff, cosh;

	radius = max(NUM_STEPS, radius);

	// calculation uses left handed system
	vnorm.z = -vnorm.z;

	for (int slice = 0; slice < NUM_SLICES; ++slice) {
		float phi = ((float(slice) + noise.x) / NUM_SLICES) * PI;

		dir = vec3(cos(phi), sin(phi), 0.0);
		horizons = vec2(-1.0);

		// calculate horizon angles
		for (int step = 0; step < NUM_STEPS; ++step) {
			float stepnoise = R1Sequence(noise.y, slice + step * NUM_STEPS);
			float currstep = (float(step) + stepnoise) / float(NUM_STEPS);

			currstep = 1.3 + currstep * currstep * radius;
			offset = round(dir.xy * currstep);

			// h1
			s = GetViewPosition(floc + offset, currstep);
			ws = s.xyz - vpos.xyz;

			dist2 = dot(ws, ws);
			invdist = inversesqrt(dist2);
			cosh = invdist * dot(ws, vdir);

			falloff = Falloff(dist2, cosh);
			horizons.x = max(horizons.x, cosh - falloff);

			// h2
			s = GetViewPosition(floc - offset, currstep);
			ws = s.xyz - vpos.xyz;

			dist2 = dot(ws, ws);
			invdist = inversesqrt(dist2);
			cosh = invdist * dot(ws, vdir);

			falloff = Falloff(dist2, cosh);
			horizons.y = max(horizons.y, cosh - falloff);
		}

		horizons = acos(horizons);

		// calculate gamma angle
		vec3 bitangent	= normalize(cross(dir, vdir));
		vec3 tangent	= cross(vdir, bitangent);
		vec3 nx			= vnorm - bitangent * dot(vnorm, bitangent);

		float nnx		= length(nx);
		float invnnx	= 1.0 / (nnx + 1e-6);			// to avoid division with zero
		float cosxi		= dot(nx, tangent) * invnnx;	// xi = gamma + HALF_PI
		float gamma		= acos(cosxi) - HALF_PI;
		float cosgamma	= dot(nx, vdir) * invnnx;
		float singamma2	= -2.0 * cosxi;					// cos(x + HALF_PI) = -sin(x)

		// clamp to normal hemisphere
		horizons.x = gamma + max(-horizons.x - gamma, -HALF_PI);
		horizons.y = gamma + min(horizons.y - gamma, HALF_PI);

		// Riemann integral is additive
		ao += nnx * 0.25 * (
			(horizons.x * singamma2 + cosgamma - cos(2.0 * horizons.x - gamma)) +
			(horizons.y * singamma2 + cosgamma - cos(2.0 * horizons.y - gamma)));
	}

	ao /= float(NUM_SLICES);

	imageStore(outputAO, loc, vec4(ao));
}
